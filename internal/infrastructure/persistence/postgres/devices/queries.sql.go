// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package devices

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveUserDevicesByUserID = `-- name: CountActiveUserDevicesByUserID :one
SELECT COUNT(*) FROM user_devices WHERE user_id = $1 AND revoked = FALSE
`

func (q *Queries) CountActiveUserDevicesByUserID(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveUserDevicesByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserDevice = `-- name: CreateUserDevice :exec
INSERT INTO user_devices (id, user_id, client_id, device_name, user_agent, ip_address, last_used_at, created_at, revoked)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateUserDeviceParams struct {
	ID         pgtype.UUID        `json:"id"`
	UserID     pgtype.UUID        `json:"user_id"`
	ClientID   string             `json:"client_id"`
	DeviceName pgtype.Text        `json:"device_name"`
	UserAgent  string             `json:"user_agent"`
	IpAddress  string             `json:"ip_address"`
	LastUsedAt pgtype.Timestamptz `json:"last_used_at"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	Revoked    bool               `json:"revoked"`
}

func (q *Queries) CreateUserDevice(ctx context.Context, arg CreateUserDeviceParams) error {
	_, err := q.db.Exec(ctx, createUserDevice,
		arg.ID,
		arg.UserID,
		arg.ClientID,
		arg.DeviceName,
		arg.UserAgent,
		arg.IpAddress,
		arg.LastUsedAt,
		arg.CreatedAt,
		arg.Revoked,
	)
	return err
}

const deleteUserDevice = `-- name: DeleteUserDevice :exec
DELETE FROM user_devices WHERE id = $1
`

func (q *Queries) DeleteUserDevice(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserDevice, id)
	return err
}

const getActiveUserDevicesByUserID = `-- name: GetActiveUserDevicesByUserID :many
SELECT id, user_id, client_id, device_name, user_agent, ip_address, last_used_at, created_at, revoked FROM user_devices WHERE user_id = $1 AND revoked = FALSE ORDER BY last_used_at DESC
`

func (q *Queries) GetActiveUserDevicesByUserID(ctx context.Context, userID pgtype.UUID) ([]UserDevice, error) {
	rows, err := q.db.Query(ctx, getActiveUserDevicesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserDevice
	for rows.Next() {
		var i UserDevice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ClientID,
			&i.DeviceName,
			&i.UserAgent,
			&i.IpAddress,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.Revoked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDeviceByID = `-- name: GetUserDeviceByID :one
SELECT id, user_id, client_id, device_name, user_agent, ip_address, last_used_at, created_at, revoked FROM user_devices WHERE id = $1
`

func (q *Queries) GetUserDeviceByID(ctx context.Context, id pgtype.UUID) (UserDevice, error) {
	row := q.db.QueryRow(ctx, getUserDeviceByID, id)
	var i UserDevice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ClientID,
		&i.DeviceName,
		&i.UserAgent,
		&i.IpAddress,
		&i.LastUsedAt,
		&i.CreatedAt,
		&i.Revoked,
	)
	return i, err
}

const getUserDevicesByUserAndClient = `-- name: GetUserDevicesByUserAndClient :many
SELECT id, user_id, client_id, device_name, user_agent, ip_address, last_used_at, created_at, revoked FROM user_devices WHERE user_id = $1 AND client_id = $2 ORDER BY last_used_at DESC
`

type GetUserDevicesByUserAndClientParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	ClientID string      `json:"client_id"`
}

func (q *Queries) GetUserDevicesByUserAndClient(ctx context.Context, arg GetUserDevicesByUserAndClientParams) ([]UserDevice, error) {
	rows, err := q.db.Query(ctx, getUserDevicesByUserAndClient, arg.UserID, arg.ClientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserDevice
	for rows.Next() {
		var i UserDevice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ClientID,
			&i.DeviceName,
			&i.UserAgent,
			&i.IpAddress,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.Revoked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDevicesByUserID = `-- name: GetUserDevicesByUserID :many
SELECT id, user_id, client_id, device_name, user_agent, ip_address, last_used_at, created_at, revoked FROM user_devices WHERE user_id = $1 ORDER BY last_used_at DESC
`

func (q *Queries) GetUserDevicesByUserID(ctx context.Context, userID pgtype.UUID) ([]UserDevice, error) {
	rows, err := q.db.Query(ctx, getUserDevicesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserDevice
	for rows.Next() {
		var i UserDevice
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ClientID,
			&i.DeviceName,
			&i.UserAgent,
			&i.IpAddress,
			&i.LastUsedAt,
			&i.CreatedAt,
			&i.Revoked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeUserDevice = `-- name: RevokeUserDevice :exec
UPDATE user_devices SET revoked = TRUE WHERE id = $1
`

func (q *Queries) RevokeUserDevice(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, revokeUserDevice, id)
	return err
}

const revokeUserDevicesByUserID = `-- name: RevokeUserDevicesByUserID :exec
UPDATE user_devices SET revoked = TRUE WHERE user_id = $1
`

func (q *Queries) RevokeUserDevicesByUserID(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, revokeUserDevicesByUserID, userID)
	return err
}

const revokeUserDevicesExceptOne = `-- name: RevokeUserDevicesExceptOne :exec
UPDATE user_devices SET revoked = TRUE WHERE user_id = $1 AND id != $2
`

type RevokeUserDevicesExceptOneParams struct {
	UserID pgtype.UUID `json:"user_id"`
	ID     pgtype.UUID `json:"id"`
}

func (q *Queries) RevokeUserDevicesExceptOne(ctx context.Context, arg RevokeUserDevicesExceptOneParams) error {
	_, err := q.db.Exec(ctx, revokeUserDevicesExceptOne, arg.UserID, arg.ID)
	return err
}

const updateUserDevice = `-- name: UpdateUserDevice :exec
UPDATE user_devices
SET device_name = $2, user_agent = $3, ip_address = $4, last_used_at = $5, revoked = $6
WHERE id = $1
`

type UpdateUserDeviceParams struct {
	ID         pgtype.UUID        `json:"id"`
	DeviceName pgtype.Text        `json:"device_name"`
	UserAgent  string             `json:"user_agent"`
	IpAddress  string             `json:"ip_address"`
	LastUsedAt pgtype.Timestamptz `json:"last_used_at"`
	Revoked    bool               `json:"revoked"`
}

func (q *Queries) UpdateUserDevice(ctx context.Context, arg UpdateUserDeviceParams) error {
	_, err := q.db.Exec(ctx, updateUserDevice,
		arg.ID,
		arg.DeviceName,
		arg.UserAgent,
		arg.IpAddress,
		arg.LastUsedAt,
		arg.Revoked,
	)
	return err
}
