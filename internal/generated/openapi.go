// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AuthorizeParamsResponseType.
const (
	AuthorizeParamsResponseTypeCode AuthorizeParamsResponseType = "code"
)

// Defines values for AuthorizeParamsCodeChallengeMethod.
const (
	AuthorizeParamsCodeChallengeMethodS256 AuthorizeParamsCodeChallengeMethod = "S256"
)

// Defines values for AuthorizeConsentFormdataBodyCodeChallengeMethod.
const (
	AuthorizeConsentFormdataBodyCodeChallengeMethodS256 AuthorizeConsentFormdataBodyCodeChallengeMethod = "S256"
)

// Defines values for AuthorizeConsentFormdataBodyResponseType.
const (
	AuthorizeConsentFormdataBodyResponseTypeCode AuthorizeConsentFormdataBodyResponseType = "code"
)

// Defines values for CreateClientJSONBodyGrantTypes.
const (
	CreateClientJSONBodyGrantTypesAuthorizationCode CreateClientJSONBodyGrantTypes = "authorization_code"
	CreateClientJSONBodyGrantTypesClientCredentials CreateClientJSONBodyGrantTypes = "client_credentials"
	CreateClientJSONBodyGrantTypesRefreshToken      CreateClientJSONBodyGrantTypes = "refresh_token"
)

// Defines values for TokenFormdataBodyGrantType.
const (
	TokenFormdataBodyGrantTypeAuthorizationCode TokenFormdataBodyGrantType = "authorization_code"
	TokenFormdataBodyGrantTypeClientCredentials TokenFormdataBodyGrantType = "client_credentials"
	TokenFormdataBodyGrantTypeRefreshToken      TokenFormdataBodyGrantType = "refresh_token"
)

// Defines values for RevokeTokenJSONBodyTokenTypeHint.
const (
	AccessToken  RevokeTokenJSONBodyTokenTypeHint = "access_token"
	RefreshToken RevokeTokenJSONBodyTokenTypeHint = "refresh_token"
)

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
	// ClientId OAuth client ID
	ClientId string              `json:"client_id"`
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
}

// LogoutParams defines parameters for Logout.
type LogoutParams struct {
	// XDeviceID Device identifier for device-bound operations
	XDeviceID *openapi_types.UUID `json:"X-Device-ID,omitempty"`
}

// RegisterJSONBody defines parameters for Register.
type RegisterJSONBody struct {
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
}

// AuthorizeParams defines parameters for Authorize.
type AuthorizeParams struct {
	// ResponseType Must be 'code' for authorization code flow
	ResponseType AuthorizeParamsResponseType `form:"response_type" json:"response_type"`

	// ClientId The OAuth client ID
	ClientId string `form:"client_id" json:"client_id"`

	// RedirectUri Callback URL for authorization response
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// Scope Space-separated list of scopes (e.g., 'openid profile email')
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`

	// State Opaque value for CSRF protection
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// CodeChallenge PKCE code challenge (base64url-encoded SHA256 hash)
	CodeChallenge string `form:"code_challenge" json:"code_challenge"`

	// CodeChallengeMethod Must be 'S256' for PKCE
	CodeChallengeMethod AuthorizeParamsCodeChallengeMethod `form:"code_challenge_method" json:"code_challenge_method"`

	// Nonce String value for ID token replay protection
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty"`
}

// AuthorizeParamsResponseType defines parameters for Authorize.
type AuthorizeParamsResponseType string

// AuthorizeParamsCodeChallengeMethod defines parameters for Authorize.
type AuthorizeParamsCodeChallengeMethod string

// AuthorizeConsentFormdataBody defines parameters for AuthorizeConsent.
type AuthorizeConsentFormdataBody struct {
	ClientId            string                                          `form:"client_id" json:"client_id"`
	CodeChallenge       string                                          `form:"code_challenge" json:"code_challenge"`
	CodeChallengeMethod AuthorizeConsentFormdataBodyCodeChallengeMethod `form:"code_challenge_method" json:"code_challenge_method"`
	Nonce               *string                                         `form:"nonce,omitempty" json:"nonce,omitempty"`
	RedirectUri         string                                          `form:"redirect_uri" json:"redirect_uri"`
	ResponseType        AuthorizeConsentFormdataBodyResponseType        `form:"response_type" json:"response_type"`
	Scope               *string                                         `form:"scope,omitempty" json:"scope,omitempty"`
	State               *string                                         `form:"state,omitempty" json:"state,omitempty"`
}

// AuthorizeConsentFormdataBodyCodeChallengeMethod defines parameters for AuthorizeConsent.
type AuthorizeConsentFormdataBodyCodeChallengeMethod string

// AuthorizeConsentFormdataBodyResponseType defines parameters for AuthorizeConsent.
type AuthorizeConsentFormdataBodyResponseType string

// ListDevicesParams defines parameters for ListDevices.
type ListDevicesParams struct {
	// XDeviceID Device identifier for device-bound operations
	XDeviceID *openapi_types.UUID `json:"X-Device-ID,omitempty"`
}

// RegisterFCMTokenJSONBody defines parameters for RegisterFCMToken.
type RegisterFCMTokenJSONBody struct {
	// FcmToken Firebase Cloud Messaging token for push notifications
	FcmToken string `json:"fcm_token"`

	// RefreshToken The refresh token to associate the FCM token with
	RefreshToken string `json:"refresh_token"`
}

// LogoutAllOthersParams defines parameters for LogoutAllOthers.
type LogoutAllOthersParams struct {
	// XDeviceID Device identifier for device-bound operations
	XDeviceID *openapi_types.UUID `json:"X-Device-ID,omitempty"`
}

// CreateClientJSONBody defines parameters for CreateClient.
type CreateClientJSONBody struct {
	// GrantTypes Allowed grant types
	GrantTypes []CreateClientJSONBodyGrantTypes `json:"grant_types"`

	// IsConfidential Whether client can keep secrets confidential
	IsConfidential *bool `json:"is_confidential,omitempty"`

	// Name Human-readable client name
	Name string `json:"name"`

	// RedirectUris Allowed redirect URIs
	RedirectUris []string `json:"redirect_uris"`

	// Scopes Allowed scopes
	Scopes *[]string `json:"scopes,omitempty"`
}

// CreateClientJSONBodyGrantTypes defines parameters for CreateClient.
type CreateClientJSONBodyGrantTypes string

// TokenFormdataBody defines parameters for Token.
type TokenFormdataBody struct {
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`

	// ClientSecret Client secret (for confidential clients)
	ClientSecret *string `form:"client_secret,omitempty" json:"client_secret,omitempty"`

	// Code Authorization code (for authorization_code grant)
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// CodeVerifier PKCE code verifier (for authorization_code grant)
	CodeVerifier *string `form:"code_verifier,omitempty" json:"code_verifier,omitempty"`

	// DeviceId Device ID (for refresh_token grant)
	DeviceId  *string                    `form:"device_id,omitempty" json:"device_id,omitempty"`
	GrantType TokenFormdataBodyGrantType `form:"grant_type" json:"grant_type"`

	// RedirectUri Must match original redirect_uri (for authorization_code grant)
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`

	// RefreshToken Refresh token (for refresh_token grant)
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty"`
	Scope        *string `form:"scope,omitempty" json:"scope,omitempty"`
}

// TokenFormdataBodyGrantType defines parameters for Token.
type TokenFormdataBodyGrantType string

// RefreshTokenJSONBody defines parameters for RefreshToken.
type RefreshTokenJSONBody struct {
	ClientId     string `json:"client_id"`
	DeviceId     string `json:"device_id"`
	RefreshToken string `json:"refresh_token"`
}

// RevokeTokenJSONBody defines parameters for RevokeToken.
type RevokeTokenJSONBody struct {
	// Token The token to revoke (access or refresh token)
	Token string `json:"token"`

	// TokenTypeHint Hint about the token type
	TokenTypeHint *RevokeTokenJSONBodyTokenTypeHint `json:"token_type_hint,omitempty"`
}

// RevokeTokenJSONBodyTokenTypeHint defines parameters for RevokeToken.
type RevokeTokenJSONBodyTokenTypeHint string

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// RegisterJSONRequestBody defines body for Register for application/json ContentType.
type RegisterJSONRequestBody RegisterJSONBody

// AuthorizeConsentFormdataRequestBody defines body for AuthorizeConsent for application/x-www-form-urlencoded ContentType.
type AuthorizeConsentFormdataRequestBody AuthorizeConsentFormdataBody

// RegisterFCMTokenJSONRequestBody defines body for RegisterFCMToken for application/json ContentType.
type RegisterFCMTokenJSONRequestBody RegisterFCMTokenJSONBody

// CreateClientJSONRequestBody defines body for CreateClient for application/json ContentType.
type CreateClientJSONRequestBody CreateClientJSONBody

// TokenFormdataRequestBody defines body for Token for application/x-www-form-urlencoded ContentType.
type TokenFormdataRequestBody TokenFormdataBody

// RefreshTokenJSONRequestBody defines body for RefreshToken for application/json ContentType.
type RefreshTokenJSONRequestBody RefreshTokenJSONBody

// RevokeTokenJSONRequestBody defines body for RevokeToken for application/json ContentType.
type RevokeTokenJSONRequestBody RevokeTokenJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetOpenIDConfiguration request
	GetOpenIDConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterWithBody request with any body
	RegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Register(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Authorize request
	Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthorizeConsentWithBody request with any body
	AuthorizeConsentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthorizeConsentWithFormdataBody(ctx context.Context, body AuthorizeConsentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDevices request
	ListDevices(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterFCMTokenWithBody request with any body
	RegisterFCMTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterFCMToken(ctx context.Context, body RegisterFCMTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealth request
	GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJWKS request
	GetJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLive request
	GetLive(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogoutAll request
	LogoutAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogoutDevice request
	LogoutDevice(ctx context.Context, deviceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogoutAllOthers request
	LogoutAllOthers(ctx context.Context, params *LogoutAllOthersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientWithBody request with any body
	CreateClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClient(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReady request
	GetReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokenWithBody request with any body
	TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TokenWithFormdataBody(ctx context.Context, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshTokenWithBody request with any body
	RefreshTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshToken(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeTokenWithBody request with any body
	RevokeTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeToken(ctx context.Context, body RevokeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFCMTokens request
	GetUserFCMTokens(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetOpenIDConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenIDConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Register(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthorizeConsentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeConsentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthorizeConsentWithFormdataBody(ctx context.Context, body AuthorizeConsentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeConsentRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDevices(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDevicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterFCMTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterFCMTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterFCMToken(ctx context.Context, body RegisterFCMTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterFCMTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJWKSRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLive(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLiveRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogoutAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutAllRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogoutDevice(ctx context.Context, deviceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutDeviceRequest(c.Server, deviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogoutAllOthers(ctx context.Context, params *LogoutAllOthersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutAllOthersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClient(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReadyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenWithFormdataBody(ctx context.Context, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshToken(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeToken(ctx context.Context, body RevokeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFCMTokens(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFCMTokensRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetOpenIDConfigurationRequest generates requests for GetOpenIDConfiguration
func NewGetOpenIDConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/.well-known/openid-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string, params *LogoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XDeviceID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Device-ID", headerParam0)
		}

	}

	return req, nil
}

// NewRegisterRequest calls the generic Register builder with application/json body
func NewRegisterRequest(server string, body RegisterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterRequestWithBody generates requests for Register with any type of body
func NewRegisterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthorizeRequest generates requests for Authorize
func NewAuthorizeRequest(server string, params *AuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge", runtime.ParamLocationQuery, params.CodeChallenge); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge_method", runtime.ParamLocationQuery, params.CodeChallengeMethod); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Nonce != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, *params.Nonce); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthorizeConsentRequestWithFormdataBody calls the generic AuthorizeConsent builder with application/x-www-form-urlencoded body
func NewAuthorizeConsentRequestWithFormdataBody(server string, body AuthorizeConsentFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewAuthorizeConsentRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewAuthorizeConsentRequestWithBody generates requests for AuthorizeConsent with any type of body
func NewAuthorizeConsentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDevicesRequest generates requests for ListDevices
func NewListDevicesRequest(server string, params *ListDevicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XDeviceID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Device-ID", headerParam0)
		}

	}

	return req, nil
}

// NewRegisterFCMTokenRequest calls the generic RegisterFCMToken builder with application/json body
func NewRegisterFCMTokenRequest(server string, body RegisterFCMTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterFCMTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterFCMTokenRequestWithBody generates requests for RegisterFCMToken with any type of body
func NewRegisterFCMTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fcm/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHealthRequest generates requests for GetHealth
func NewGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJWKSRequest generates requests for GetJWKS
func NewGetJWKSRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwks.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLiveRequest generates requests for GetLive
func NewGetLiveRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/live")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogoutAllRequest generates requests for LogoutAll
func NewLogoutAllRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogoutDeviceRequest generates requests for LogoutDevice
func NewLogoutDeviceRequest(server string, deviceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "device_id", runtime.ParamLocationPath, deviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout/device/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogoutAllOthersRequest generates requests for LogoutAllOthers
func NewLogoutAllOthersRequest(server string, params *LogoutAllOthersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout/others")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XDeviceID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Device-ID", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientRequest calls the generic CreateClient builder with application/json body
func NewCreateClientRequest(server string, body CreateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateClientRequestWithBody generates requests for CreateClient with any type of body
func NewCreateClientRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/client")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReadyRequest generates requests for GetReady
func NewGetReadyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTokenRequestWithFormdataBody calls the generic Token builder with application/x-www-form-urlencoded body
func NewTokenRequestWithFormdataBody(server string, body TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTokenRequestWithBody generates requests for Token with any type of body
func NewTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshTokenRequest calls the generic RefreshToken builder with application/json body
func NewRefreshTokenRequest(server string, body RefreshTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefreshTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewRefreshTokenRequestWithBody generates requests for RefreshToken with any type of body
func NewRefreshTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokeTokenRequest calls the generic RevokeToken builder with application/json body
func NewRevokeTokenRequest(server string, body RevokeTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevokeTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewRevokeTokenRequestWithBody generates requests for RevokeToken with any type of body
func NewRevokeTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token/revoke")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserFCMTokensRequest generates requests for GetUserFCMTokens
func NewGetUserFCMTokensRequest(server string, userId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/fcm-tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetOpenIDConfigurationWithResponse request
	GetOpenIDConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenIDConfigurationResponse, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// RegisterWithBodyWithResponse request with any body
	RegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterResponse, error)

	RegisterWithResponse(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterResponse, error)

	// AuthorizeWithResponse request
	AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error)

	// AuthorizeConsentWithBodyWithResponse request with any body
	AuthorizeConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthorizeConsentResponse, error)

	AuthorizeConsentWithFormdataBodyWithResponse(ctx context.Context, body AuthorizeConsentFormdataRequestBody, reqEditors ...RequestEditorFn) (*AuthorizeConsentResponse, error)

	// ListDevicesWithResponse request
	ListDevicesWithResponse(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*ListDevicesResponse, error)

	// RegisterFCMTokenWithBodyWithResponse request with any body
	RegisterFCMTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterFCMTokenResponse, error)

	RegisterFCMTokenWithResponse(ctx context.Context, body RegisterFCMTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterFCMTokenResponse, error)

	// GetHealthWithResponse request
	GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error)

	// GetJWKSWithResponse request
	GetJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJWKSResponse, error)

	// GetLiveWithResponse request
	GetLiveWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLiveResponse, error)

	// LogoutAllWithResponse request
	LogoutAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutAllResponse, error)

	// LogoutDeviceWithResponse request
	LogoutDeviceWithResponse(ctx context.Context, deviceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*LogoutDeviceResponse, error)

	// LogoutAllOthersWithResponse request
	LogoutAllOthersWithResponse(ctx context.Context, params *LogoutAllOthersParams, reqEditors ...RequestEditorFn) (*LogoutAllOthersResponse, error)

	// CreateClientWithBodyWithResponse request with any body
	CreateClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	CreateClientWithResponse(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	// GetReadyWithResponse request
	GetReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadyResponse, error)

	// TokenWithBodyWithResponse request with any body
	TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	TokenWithFormdataBodyWithResponse(ctx context.Context, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	// RefreshTokenWithBodyWithResponse request with any body
	RefreshTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error)

	RefreshTokenWithResponse(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error)

	// RevokeTokenWithBodyWithResponse request with any body
	RevokeTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error)

	RevokeTokenWithResponse(ctx context.Context, body RevokeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error)

	// GetUserFCMTokensWithResponse request
	GetUserFCMTokensWithResponse(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserFCMTokensResponse, error)
}

type GetOpenIDConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AuthorizationEndpoint             *string   `json:"authorization_endpoint,omitempty"`
		ClaimsSupported                   *[]string `json:"claims_supported,omitempty"`
		CodeChallengeMethodsSupported     *[]string `json:"code_challenge_methods_supported,omitempty"`
		EndSessionEndpoint                *string   `json:"end_session_endpoint,omitempty"`
		GrantTypesSupported               *[]string `json:"grant_types_supported,omitempty"`
		IdTokenSigningAlgValuesSupported  *[]string `json:"id_token_signing_alg_values_supported,omitempty"`
		IntrospectionEndpoint             *string   `json:"introspection_endpoint,omitempty"`
		Issuer                            *string   `json:"issuer,omitempty"`
		JwksUri                           *string   `json:"jwks_uri,omitempty"`
		RegistrationEndpoint              *string   `json:"registration_endpoint,omitempty"`
		ResponseModesSupported            *[]string `json:"response_modes_supported,omitempty"`
		ResponseTypesSupported            *[]string `json:"response_types_supported,omitempty"`
		RevocationEndpoint                *string   `json:"revocation_endpoint,omitempty"`
		ScopesSupported                   *[]string `json:"scopes_supported,omitempty"`
		SubjectTypesSupported             *[]string `json:"subject_types_supported,omitempty"`
		TokenEndpoint                     *string   `json:"token_endpoint,omitempty"`
		TokenEndpointAuthMethodsSupported *[]string `json:"token_endpoint_auth_methods_supported,omitempty"`
		UserinfoEndpoint                  *string   `json:"userinfo_endpoint,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOpenIDConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenIDConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AccessToken JWT access token
		AccessToken *string `json:"access_token,omitempty"`

		// DeviceId Server-assigned device identifier
		DeviceId *openapi_types.UUID `json:"device_id,omitempty"`

		// ExpiresIn Token lifetime in seconds
		ExpiresIn *int `json:"expires_in,omitempty"`

		// IdToken OpenID Connect ID token (when openid scope requested)
		IdToken *string `json:"id_token,omitempty"`

		// RefreshToken Refresh token for obtaining new access tokens
		RefreshToken *string `json:"refresh_token,omitempty"`

		// Scope Granted scopes
		Scope     *string `json:"scope,omitempty"`
		TokenType *string `json:"token_type,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		CreatedAt     *time.Time           `json:"created_at,omitempty"`
		Email         *openapi_types.Email `json:"email,omitempty"`
		EmailVerified *bool                `json:"email_verified,omitempty"`
		UserId        *openapi_types.UUID  `json:"user_id,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON409 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r RegisterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ClientId    *string `json:"client_id,omitempty"`
		ClientName  *string `json:"client_name,omitempty"`
		Message     *string `json:"message,omitempty"`
		RedirectUri *string `json:"redirect_uri,omitempty"`
		Scope       *string `json:"scope,omitempty"`
		State       *string `json:"state,omitempty"`
	}
	JSON400 *struct {
		// Error OAuth error code
		Error Authorize400Error `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription *string `json:"error_description,omitempty"`
	}
}
type Authorize400Error string

// Status returns HTTPResponse.Status
func (r AuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		// Error OAuth error code
		Error AuthorizeConsent400Error `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription *string `json:"error_description,omitempty"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}
type AuthorizeConsent400Error string

// Status returns HTTPResponse.Status
func (r AuthorizeConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Devices *[]struct {
			CreatedAt  *time.Time          `json:"created_at,omitempty"`
			DeviceId   *openapi_types.UUID `json:"device_id,omitempty"`
			DeviceName *string             `json:"device_name,omitempty"`
			IpAddress  *string             `json:"ip_address,omitempty"`

			// IsCurrent Whether this is the current device making the request
			IsCurrent  *bool      `json:"is_current,omitempty"`
			LastUsedAt *time.Time `json:"last_used_at,omitempty"`
			UserAgent  *string    `json:"user_agent,omitempty"`
		} `json:"devices,omitempty"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterFCMTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r RegisterFCMTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterFCMTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Checks struct {
			Database *GetHealth200ChecksDatabase `json:"database,omitempty"`
			Redis    *GetHealth200ChecksRedis    `json:"redis,omitempty"`
		} `json:"checks"`
		Status GetHealth200Status `json:"status"`
	}
	JSON503 *struct {
		Checks struct {
			Database *GetHealth503ChecksDatabase `json:"database,omitempty"`
			Redis    *GetHealth503ChecksRedis    `json:"redis,omitempty"`
		} `json:"checks"`
		Status GetHealth503Status `json:"status"`
	}
}
type GetHealth200ChecksDatabase string
type GetHealth200ChecksRedis string
type GetHealth200Status string
type GetHealth503ChecksDatabase string
type GetHealth503ChecksRedis string
type GetHealth503Status string

// Status returns HTTPResponse.Status
func (r GetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJWKSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Keys *[]struct {
			Alg *string `json:"alg,omitempty"`

			// E RSA exponent (base64url encoded)
			E *string `json:"e,omitempty"`

			// Kid Key ID
			Kid *string `json:"kid,omitempty"`
			Kty *string `json:"kty,omitempty"`

			// N RSA modulus (base64url encoded)
			N   *string `json:"n,omitempty"`
			Use *string `json:"use,omitempty"`
		} `json:"keys,omitempty"`
	}
	JSON500 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJWKSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJWKSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Alive *bool `json:"alive,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r LogoutAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON404 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r LogoutDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutAllOthersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r LogoutAllOthersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutAllOthersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// ClientId OAuth client ID
		ClientId *string `json:"client_id,omitempty"`

		// ClientSecret Client secret (only returned on creation)
		ClientSecret *string             `json:"client_secret,omitempty"`
		CreatedAt    *time.Time          `json:"created_at,omitempty"`
		GrantTypes   *[]string           `json:"grant_types,omitempty"`
		Id           *openapi_types.UUID `json:"id,omitempty"`
		Name         *string             `json:"name,omitempty"`
		RedirectUris *[]string           `json:"redirect_uris,omitempty"`
		Scopes       *[]string           `json:"scopes,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON500 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ready *bool `json:"ready,omitempty"`
	}
	JSON503 *struct {
		Ready *bool `json:"ready,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccessToken  *string `json:"access_token,omitempty"`
		DeviceId     *string `json:"device_id,omitempty"`
		ExpiresIn    *int    `json:"expires_in,omitempty"`
		IdToken      *string `json:"id_token,omitempty"`
		RefreshToken *string `json:"refresh_token,omitempty"`
		Scope        *string `json:"scope,omitempty"`
		TokenType    *string `json:"token_type,omitempty"`
	}
	JSON400 *struct {
		// Error OAuth error code
		Error Token400Error `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription *string `json:"error_description,omitempty"`
	}
	JSON401 *struct {
		// Error OAuth error code
		Error Token401Error `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription *string `json:"error_description,omitempty"`
	}
}
type Token400Error string
type Token401Error string

// Status returns HTTPResponse.Status
func (r TokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccessToken  *string `json:"access_token,omitempty"`
		DeviceId     *string `json:"device_id,omitempty"`
		ExpiresIn    *int    `json:"expires_in,omitempty"`
		IdToken      *string `json:"id_token,omitempty"`
		RefreshToken *string `json:"refresh_token,omitempty"`
		Scope        *string `json:"scope,omitempty"`
		TokenType    *string `json:"token_type,omitempty"`
	}
	JSON400 *struct {
		// Error OAuth error code
		Error RefreshToken400Error `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription *string `json:"error_description,omitempty"`
	}
}
type RefreshToken400Error string

// Status returns HTTPResponse.Status
func (r RefreshTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Revoked *bool `json:"revoked,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokeTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFCMTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// FcmTokens List of active FCM tokens for the user
		FcmTokens *[]string `json:"fcm_tokens,omitempty"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON403 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserFCMTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFCMTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetOpenIDConfigurationWithResponse request returning *GetOpenIDConfigurationResponse
func (c *ClientWithResponses) GetOpenIDConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenIDConfigurationResponse, error) {
	rsp, err := c.GetOpenIDConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenIDConfigurationResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// RegisterWithBodyWithResponse request with arbitrary body returning *RegisterResponse
func (c *ClientWithResponses) RegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterResponse, error) {
	rsp, err := c.RegisterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterResponse(rsp)
}

func (c *ClientWithResponses) RegisterWithResponse(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterResponse, error) {
	rsp, err := c.Register(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterResponse(rsp)
}

// AuthorizeWithResponse request returning *AuthorizeResponse
func (c *ClientWithResponses) AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error) {
	rsp, err := c.Authorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeResponse(rsp)
}

// AuthorizeConsentWithBodyWithResponse request with arbitrary body returning *AuthorizeConsentResponse
func (c *ClientWithResponses) AuthorizeConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthorizeConsentResponse, error) {
	rsp, err := c.AuthorizeConsentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeConsentResponse(rsp)
}

func (c *ClientWithResponses) AuthorizeConsentWithFormdataBodyWithResponse(ctx context.Context, body AuthorizeConsentFormdataRequestBody, reqEditors ...RequestEditorFn) (*AuthorizeConsentResponse, error) {
	rsp, err := c.AuthorizeConsentWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeConsentResponse(rsp)
}

// ListDevicesWithResponse request returning *ListDevicesResponse
func (c *ClientWithResponses) ListDevicesWithResponse(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*ListDevicesResponse, error) {
	rsp, err := c.ListDevices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDevicesResponse(rsp)
}

// RegisterFCMTokenWithBodyWithResponse request with arbitrary body returning *RegisterFCMTokenResponse
func (c *ClientWithResponses) RegisterFCMTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterFCMTokenResponse, error) {
	rsp, err := c.RegisterFCMTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterFCMTokenResponse(rsp)
}

func (c *ClientWithResponses) RegisterFCMTokenWithResponse(ctx context.Context, body RegisterFCMTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterFCMTokenResponse, error) {
	rsp, err := c.RegisterFCMToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterFCMTokenResponse(rsp)
}

// GetHealthWithResponse request returning *GetHealthResponse
func (c *ClientWithResponses) GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error) {
	rsp, err := c.GetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthResponse(rsp)
}

// GetJWKSWithResponse request returning *GetJWKSResponse
func (c *ClientWithResponses) GetJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJWKSResponse, error) {
	rsp, err := c.GetJWKS(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJWKSResponse(rsp)
}

// GetLiveWithResponse request returning *GetLiveResponse
func (c *ClientWithResponses) GetLiveWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLiveResponse, error) {
	rsp, err := c.GetLive(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLiveResponse(rsp)
}

// LogoutAllWithResponse request returning *LogoutAllResponse
func (c *ClientWithResponses) LogoutAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutAllResponse, error) {
	rsp, err := c.LogoutAll(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutAllResponse(rsp)
}

// LogoutDeviceWithResponse request returning *LogoutDeviceResponse
func (c *ClientWithResponses) LogoutDeviceWithResponse(ctx context.Context, deviceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*LogoutDeviceResponse, error) {
	rsp, err := c.LogoutDevice(ctx, deviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutDeviceResponse(rsp)
}

// LogoutAllOthersWithResponse request returning *LogoutAllOthersResponse
func (c *ClientWithResponses) LogoutAllOthersWithResponse(ctx context.Context, params *LogoutAllOthersParams, reqEditors ...RequestEditorFn) (*LogoutAllOthersResponse, error) {
	rsp, err := c.LogoutAllOthers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutAllOthersResponse(rsp)
}

// CreateClientWithBodyWithResponse request with arbitrary body returning *CreateClientResponse
func (c *ClientWithResponses) CreateClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClientWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

func (c *ClientWithResponses) CreateClientWithResponse(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClient(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

// GetReadyWithResponse request returning *GetReadyResponse
func (c *ClientWithResponses) GetReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadyResponse, error) {
	rsp, err := c.GetReady(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReadyResponse(rsp)
}

// TokenWithBodyWithResponse request with arbitrary body returning *TokenResponse
func (c *ClientWithResponses) TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.TokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

func (c *ClientWithResponses) TokenWithFormdataBodyWithResponse(ctx context.Context, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.TokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

// RefreshTokenWithBodyWithResponse request with arbitrary body returning *RefreshTokenResponse
func (c *ClientWithResponses) RefreshTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error) {
	rsp, err := c.RefreshTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenResponse(rsp)
}

func (c *ClientWithResponses) RefreshTokenWithResponse(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error) {
	rsp, err := c.RefreshToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenResponse(rsp)
}

// RevokeTokenWithBodyWithResponse request with arbitrary body returning *RevokeTokenResponse
func (c *ClientWithResponses) RevokeTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error) {
	rsp, err := c.RevokeTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeTokenResponse(rsp)
}

func (c *ClientWithResponses) RevokeTokenWithResponse(ctx context.Context, body RevokeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error) {
	rsp, err := c.RevokeToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeTokenResponse(rsp)
}

// GetUserFCMTokensWithResponse request returning *GetUserFCMTokensResponse
func (c *ClientWithResponses) GetUserFCMTokensWithResponse(ctx context.Context, userId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserFCMTokensResponse, error) {
	rsp, err := c.GetUserFCMTokens(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFCMTokensResponse(rsp)
}

// ParseGetOpenIDConfigurationResponse parses an HTTP response from a GetOpenIDConfigurationWithResponse call
func ParseGetOpenIDConfigurationResponse(rsp *http.Response) (*GetOpenIDConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenIDConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AuthorizationEndpoint             *string   `json:"authorization_endpoint,omitempty"`
			ClaimsSupported                   *[]string `json:"claims_supported,omitempty"`
			CodeChallengeMethodsSupported     *[]string `json:"code_challenge_methods_supported,omitempty"`
			EndSessionEndpoint                *string   `json:"end_session_endpoint,omitempty"`
			GrantTypesSupported               *[]string `json:"grant_types_supported,omitempty"`
			IdTokenSigningAlgValuesSupported  *[]string `json:"id_token_signing_alg_values_supported,omitempty"`
			IntrospectionEndpoint             *string   `json:"introspection_endpoint,omitempty"`
			Issuer                            *string   `json:"issuer,omitempty"`
			JwksUri                           *string   `json:"jwks_uri,omitempty"`
			RegistrationEndpoint              *string   `json:"registration_endpoint,omitempty"`
			ResponseModesSupported            *[]string `json:"response_modes_supported,omitempty"`
			ResponseTypesSupported            *[]string `json:"response_types_supported,omitempty"`
			RevocationEndpoint                *string   `json:"revocation_endpoint,omitempty"`
			ScopesSupported                   *[]string `json:"scopes_supported,omitempty"`
			SubjectTypesSupported             *[]string `json:"subject_types_supported,omitempty"`
			TokenEndpoint                     *string   `json:"token_endpoint,omitempty"`
			TokenEndpointAuthMethodsSupported *[]string `json:"token_endpoint_auth_methods_supported,omitempty"`
			UserinfoEndpoint                  *string   `json:"userinfo_endpoint,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AccessToken JWT access token
			AccessToken *string `json:"access_token,omitempty"`

			// DeviceId Server-assigned device identifier
			DeviceId *openapi_types.UUID `json:"device_id,omitempty"`

			// ExpiresIn Token lifetime in seconds
			ExpiresIn *int `json:"expires_in,omitempty"`

			// IdToken OpenID Connect ID token (when openid scope requested)
			IdToken *string `json:"id_token,omitempty"`

			// RefreshToken Refresh token for obtaining new access tokens
			RefreshToken *string `json:"refresh_token,omitempty"`

			// Scope Granted scopes
			Scope     *string `json:"scope,omitempty"`
			TokenType *string `json:"token_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRegisterResponse parses an HTTP response from a RegisterWithResponse call
func ParseRegisterResponse(rsp *http.Response) (*RegisterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			CreatedAt     *time.Time           `json:"created_at,omitempty"`
			Email         *openapi_types.Email `json:"email,omitempty"`
			EmailVerified *bool                `json:"email_verified,omitempty"`
			UserId        *openapi_types.UUID  `json:"user_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAuthorizeResponse parses an HTTP response from a AuthorizeWithResponse call
func ParseAuthorizeResponse(rsp *http.Response) (*AuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ClientId    *string `json:"client_id,omitempty"`
			ClientName  *string `json:"client_name,omitempty"`
			Message     *string `json:"message,omitempty"`
			RedirectUri *string `json:"redirect_uri,omitempty"`
			Scope       *string `json:"scope,omitempty"`
			State       *string `json:"state,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error OAuth error code
			Error Authorize400Error `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription *string `json:"error_description,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAuthorizeConsentResponse parses an HTTP response from a AuthorizeConsentWithResponse call
func ParseAuthorizeConsentResponse(rsp *http.Response) (*AuthorizeConsentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error OAuth error code
			Error AuthorizeConsent400Error `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription *string `json:"error_description,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListDevicesResponse parses an HTTP response from a ListDevicesWithResponse call
func ParseListDevicesResponse(rsp *http.Response) (*ListDevicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Devices *[]struct {
				CreatedAt  *time.Time          `json:"created_at,omitempty"`
				DeviceId   *openapi_types.UUID `json:"device_id,omitempty"`
				DeviceName *string             `json:"device_name,omitempty"`
				IpAddress  *string             `json:"ip_address,omitempty"`

				// IsCurrent Whether this is the current device making the request
				IsCurrent  *bool      `json:"is_current,omitempty"`
				LastUsedAt *time.Time `json:"last_used_at,omitempty"`
				UserAgent  *string    `json:"user_agent,omitempty"`
			} `json:"devices,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRegisterFCMTokenResponse parses an HTTP response from a RegisterFCMTokenWithResponse call
func ParseRegisterFCMTokenResponse(rsp *http.Response) (*RegisterFCMTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterFCMTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetHealthResponse parses an HTTP response from a GetHealthWithResponse call
func ParseGetHealthResponse(rsp *http.Response) (*GetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Checks struct {
				Database *GetHealth200ChecksDatabase `json:"database,omitempty"`
				Redis    *GetHealth200ChecksRedis    `json:"redis,omitempty"`
			} `json:"checks"`
			Status GetHealth200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Checks struct {
				Database *GetHealth503ChecksDatabase `json:"database,omitempty"`
				Redis    *GetHealth503ChecksRedis    `json:"redis,omitempty"`
			} `json:"checks"`
			Status GetHealth503Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetJWKSResponse parses an HTTP response from a GetJWKSWithResponse call
func ParseGetJWKSResponse(rsp *http.Response) (*GetJWKSResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJWKSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Keys *[]struct {
				Alg *string `json:"alg,omitempty"`

				// E RSA exponent (base64url encoded)
				E *string `json:"e,omitempty"`

				// Kid Key ID
				Kid *string `json:"kid,omitempty"`
				Kty *string `json:"kty,omitempty"`

				// N RSA modulus (base64url encoded)
				N   *string `json:"n,omitempty"`
				Use *string `json:"use,omitempty"`
			} `json:"keys,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLiveResponse parses an HTTP response from a GetLiveWithResponse call
func ParseGetLiveResponse(rsp *http.Response) (*GetLiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Alive *bool `json:"alive,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLogoutAllResponse parses an HTTP response from a LogoutAllWithResponse call
func ParseLogoutAllResponse(rsp *http.Response) (*LogoutAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLogoutDeviceResponse parses an HTTP response from a LogoutDeviceWithResponse call
func ParseLogoutDeviceResponse(rsp *http.Response) (*LogoutDeviceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseLogoutAllOthersResponse parses an HTTP response from a LogoutAllOthersWithResponse call
func ParseLogoutAllOthersResponse(rsp *http.Response) (*LogoutAllOthersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutAllOthersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateClientResponse parses an HTTP response from a CreateClientWithResponse call
func ParseCreateClientResponse(rsp *http.Response) (*CreateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// ClientId OAuth client ID
			ClientId *string `json:"client_id,omitempty"`

			// ClientSecret Client secret (only returned on creation)
			ClientSecret *string             `json:"client_secret,omitempty"`
			CreatedAt    *time.Time          `json:"created_at,omitempty"`
			GrantTypes   *[]string           `json:"grant_types,omitempty"`
			Id           *openapi_types.UUID `json:"id,omitempty"`
			Name         *string             `json:"name,omitempty"`
			RedirectUris *[]string           `json:"redirect_uris,omitempty"`
			Scopes       *[]string           `json:"scopes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReadyResponse parses an HTTP response from a GetReadyWithResponse call
func ParseGetReadyResponse(rsp *http.Response) (*GetReadyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ready *bool `json:"ready,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Ready *bool `json:"ready,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTokenResponse parses an HTTP response from a TokenWithResponse call
func ParseTokenResponse(rsp *http.Response) (*TokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccessToken  *string `json:"access_token,omitempty"`
			DeviceId     *string `json:"device_id,omitempty"`
			ExpiresIn    *int    `json:"expires_in,omitempty"`
			IdToken      *string `json:"id_token,omitempty"`
			RefreshToken *string `json:"refresh_token,omitempty"`
			Scope        *string `json:"scope,omitempty"`
			TokenType    *string `json:"token_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error OAuth error code
			Error Token400Error `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription *string `json:"error_description,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error OAuth error code
			Error Token401Error `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription *string `json:"error_description,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRefreshTokenResponse parses an HTTP response from a RefreshTokenWithResponse call
func ParseRefreshTokenResponse(rsp *http.Response) (*RefreshTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccessToken  *string `json:"access_token,omitempty"`
			DeviceId     *string `json:"device_id,omitempty"`
			ExpiresIn    *int    `json:"expires_in,omitempty"`
			IdToken      *string `json:"id_token,omitempty"`
			RefreshToken *string `json:"refresh_token,omitempty"`
			Scope        *string `json:"scope,omitempty"`
			TokenType    *string `json:"token_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error OAuth error code
			Error RefreshToken400Error `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription *string `json:"error_description,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRevokeTokenResponse parses an HTTP response from a RevokeTokenWithResponse call
func ParseRevokeTokenResponse(rsp *http.Response) (*RevokeTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Revoked *bool `json:"revoked,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetUserFCMTokensResponse parses an HTTP response from a GetUserFCMTokensWithResponse call
func ParseGetUserFCMTokensResponse(rsp *http.Response) (*GetUserFCMTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFCMTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// FcmTokens List of active FCM tokens for the user
			FcmTokens *[]string `json:"fcm_tokens,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// OpenID Connect discovery document
	// (GET /.well-known/openid-configuration)
	GetOpenIDConfiguration(c *gin.Context)
	// User login
	// (POST /auth/login)
	Login(c *gin.Context)
	// Logout current device
	// (POST /auth/logout)
	Logout(c *gin.Context, params LogoutParams)
	// Register a new user
	// (POST /auth/register)
	Register(c *gin.Context)
	// Authorization endpoint
	// (GET /authorize)
	Authorize(c *gin.Context, params AuthorizeParams)
	// Authorization consent
	// (POST /authorize)
	AuthorizeConsent(c *gin.Context)
	// List user devices
	// (GET /devices)
	ListDevices(c *gin.Context, params ListDevicesParams)
	// Register FCM token
	// (POST /fcm/register)
	RegisterFCMToken(c *gin.Context)
	// Service health status
	// (GET /health)
	GetHealth(c *gin.Context)
	// JSON Web Key Set
	// (GET /jwks.json)
	GetJWKS(c *gin.Context)
	// Service liveness
	// (GET /live)
	GetLive(c *gin.Context)
	// Logout all devices
	// (POST /logout/all)
	LogoutAll(c *gin.Context)
	// Logout specific device
	// (POST /logout/device/{device_id})
	LogoutDevice(c *gin.Context, deviceId openapi_types.UUID)
	// Logout all other devices
	// (POST /logout/others)
	LogoutAllOthers(c *gin.Context, params LogoutAllOthersParams)
	// Create OAuth client
	// (POST /oauth/client)
	CreateClient(c *gin.Context)
	// Service readiness
	// (GET /ready)
	GetReady(c *gin.Context)
	// Token endpoint
	// (POST /token)
	Token(c *gin.Context)
	// Refresh token
	// (POST /token/refresh)
	RefreshToken(c *gin.Context)
	// Revoke token
	// (POST /token/revoke)
	RevokeToken(c *gin.Context)
	// Get user FCM tokens
	// (GET /users/{user_id}/fcm-tokens)
	GetUserFCMTokens(c *gin.Context, userId openapi_types.UUID)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetOpenIDConfiguration operation middleware
func (siw *ServerInterfaceWrapper) GetOpenIDConfiguration(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetOpenIDConfiguration(c)
}

// Login operation middleware
func (siw *ServerInterfaceWrapper) Login(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Login(c)
}

// Logout operation middleware
func (siw *ServerInterfaceWrapper) Logout(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params LogoutParams

	headers := c.Request.Header

	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Device-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Device-ID", valueList[0], &XDeviceID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Device-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XDeviceID = &XDeviceID

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Logout(c, params)
}

// Register operation middleware
func (siw *ServerInterfaceWrapper) Register(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Register(c)
}

// Authorize operation middleware
func (siw *ServerInterfaceWrapper) Authorize(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthorizeParams

	// ------------- Required query parameter "response_type" -------------

	if paramValue := c.Query("response_type"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument response_type is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "response_type", c.Request.URL.Query(), &params.ResponseType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter response_type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "client_id" -------------

	if paramValue := c.Query("client_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument client_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "client_id", c.Request.URL.Query(), &params.ClientId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter client_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "redirect_uri" -------------

	if paramValue := c.Query("redirect_uri"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument redirect_uri is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "redirect_uri", c.Request.URL.Query(), &params.RedirectUri)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter redirect_uri: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "scope" -------------

	err = runtime.BindQueryParameter("form", true, false, "scope", c.Request.URL.Query(), &params.Scope)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter scope: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", c.Request.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter state: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "code_challenge" -------------

	if paramValue := c.Query("code_challenge"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument code_challenge is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "code_challenge", c.Request.URL.Query(), &params.CodeChallenge)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter code_challenge: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "code_challenge_method" -------------

	if paramValue := c.Query("code_challenge_method"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument code_challenge_method is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "code_challenge_method", c.Request.URL.Query(), &params.CodeChallengeMethod)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter code_challenge_method: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "nonce" -------------

	err = runtime.BindQueryParameter("form", true, false, "nonce", c.Request.URL.Query(), &params.Nonce)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nonce: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Authorize(c, params)
}

// AuthorizeConsent operation middleware
func (siw *ServerInterfaceWrapper) AuthorizeConsent(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AuthorizeConsent(c)
}

// ListDevices operation middleware
func (siw *ServerInterfaceWrapper) ListDevices(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDevicesParams

	headers := c.Request.Header

	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Device-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Device-ID", valueList[0], &XDeviceID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Device-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XDeviceID = &XDeviceID

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListDevices(c, params)
}

// RegisterFCMToken operation middleware
func (siw *ServerInterfaceWrapper) RegisterFCMToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RegisterFCMToken(c)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// GetJWKS operation middleware
func (siw *ServerInterfaceWrapper) GetJWKS(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetJWKS(c)
}

// GetLive operation middleware
func (siw *ServerInterfaceWrapper) GetLive(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetLive(c)
}

// LogoutAll operation middleware
func (siw *ServerInterfaceWrapper) LogoutAll(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LogoutAll(c)
}

// LogoutDevice operation middleware
func (siw *ServerInterfaceWrapper) LogoutDevice(c *gin.Context) {

	var err error

	// ------------- Path parameter "device_id" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "device_id", c.Param("device_id"), &deviceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter device_id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LogoutDevice(c, deviceId)
}

// LogoutAllOthers operation middleware
func (siw *ServerInterfaceWrapper) LogoutAllOthers(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params LogoutAllOthersParams

	headers := c.Request.Header

	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Device-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Device-ID", valueList[0], &XDeviceID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Device-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XDeviceID = &XDeviceID

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LogoutAllOthers(c, params)
}

// CreateClient operation middleware
func (siw *ServerInterfaceWrapper) CreateClient(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateClient(c)
}

// GetReady operation middleware
func (siw *ServerInterfaceWrapper) GetReady(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetReady(c)
}

// Token operation middleware
func (siw *ServerInterfaceWrapper) Token(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Token(c)
}

// RefreshToken operation middleware
func (siw *ServerInterfaceWrapper) RefreshToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RefreshToken(c)
}

// RevokeToken operation middleware
func (siw *ServerInterfaceWrapper) RevokeToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RevokeToken(c)
}

// GetUserFCMTokens operation middleware
func (siw *ServerInterfaceWrapper) GetUserFCMTokens(c *gin.Context) {

	var err error

	// ------------- Path parameter "user_id" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "user_id", c.Param("user_id"), &userId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter user_id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetUserFCMTokens(c, userId)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/.well-known/openid-configuration", wrapper.GetOpenIDConfiguration)
	router.POST(options.BaseURL+"/auth/login", wrapper.Login)
	router.POST(options.BaseURL+"/auth/logout", wrapper.Logout)
	router.POST(options.BaseURL+"/auth/register", wrapper.Register)
	router.GET(options.BaseURL+"/authorize", wrapper.Authorize)
	router.POST(options.BaseURL+"/authorize", wrapper.AuthorizeConsent)
	router.GET(options.BaseURL+"/devices", wrapper.ListDevices)
	router.POST(options.BaseURL+"/fcm/register", wrapper.RegisterFCMToken)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.GET(options.BaseURL+"/jwks.json", wrapper.GetJWKS)
	router.GET(options.BaseURL+"/live", wrapper.GetLive)
	router.POST(options.BaseURL+"/logout/all", wrapper.LogoutAll)
	router.POST(options.BaseURL+"/logout/device/:device_id", wrapper.LogoutDevice)
	router.POST(options.BaseURL+"/logout/others", wrapper.LogoutAllOthers)
	router.POST(options.BaseURL+"/oauth/client", wrapper.CreateClient)
	router.GET(options.BaseURL+"/ready", wrapper.GetReady)
	router.POST(options.BaseURL+"/token", wrapper.Token)
	router.POST(options.BaseURL+"/token/refresh", wrapper.RefreshToken)
	router.POST(options.BaseURL+"/token/revoke", wrapper.RevokeToken)
	router.GET(options.BaseURL+"/users/:user_id/fcm-tokens", wrapper.GetUserFCMTokens)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/PD8fwEAAP//jJarBhNyAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
