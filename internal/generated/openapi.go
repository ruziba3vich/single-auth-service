// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AuthorizeParamsResponseType.
const (
	AuthorizeParamsResponseTypeCode AuthorizeParamsResponseType = "code"
)

// Defines values for AuthorizeParamsCodeChallengeMethod.
const (
	AuthorizeParamsCodeChallengeMethodS256 AuthorizeParamsCodeChallengeMethod = "S256"
)

// Defines values for AuthorizeConsentFormdataBodyCodeChallengeMethod.
const (
	AuthorizeConsentFormdataBodyCodeChallengeMethodS256 AuthorizeConsentFormdataBodyCodeChallengeMethod = "S256"
)

// Defines values for AuthorizeConsentFormdataBodyResponseType.
const (
	AuthorizeConsentFormdataBodyResponseTypeCode AuthorizeConsentFormdataBodyResponseType = "code"
)

// Defines values for CreateClientJSONBodyGrantTypes.
const (
	CreateClientJSONBodyGrantTypesAuthorizationCode CreateClientJSONBodyGrantTypes = "authorization_code"
	CreateClientJSONBodyGrantTypesClientCredentials CreateClientJSONBodyGrantTypes = "client_credentials"
	CreateClientJSONBodyGrantTypesRefreshToken      CreateClientJSONBodyGrantTypes = "refresh_token"
)

// Defines values for TokenFormdataBodyGrantType.
const (
	TokenFormdataBodyGrantTypeAuthorizationCode TokenFormdataBodyGrantType = "authorization_code"
	TokenFormdataBodyGrantTypeClientCredentials TokenFormdataBodyGrantType = "client_credentials"
	TokenFormdataBodyGrantTypeRefreshToken      TokenFormdataBodyGrantType = "refresh_token"
)

// Defines values for RevokeTokenJSONBodyTokenTypeHint.
const (
	AccessToken  RevokeTokenJSONBodyTokenTypeHint = "access_token"
	RefreshToken RevokeTokenJSONBodyTokenTypeHint = "refresh_token"
)

// LoginJSONBody defines parameters for Login.
type LoginJSONBody struct {
	// ClientId OAuth client ID
	ClientId string              `json:"client_id"`
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
}

// LogoutParams defines parameters for Logout.
type LogoutParams struct {
	// XDeviceID Device identifier for device-bound operations
	XDeviceID *openapi_types.UUID `json:"X-Device-ID,omitempty"`
}

// RegisterJSONBody defines parameters for Register.
type RegisterJSONBody struct {
	Email    openapi_types.Email `json:"email"`
	Password string              `json:"password"`
}

// AuthorizeParams defines parameters for Authorize.
type AuthorizeParams struct {
	// ResponseType Must be 'code' for authorization code flow
	ResponseType AuthorizeParamsResponseType `form:"response_type" json:"response_type"`

	// ClientId The OAuth client ID
	ClientId string `form:"client_id" json:"client_id"`

	// RedirectUri Callback URL for authorization response
	RedirectUri string `form:"redirect_uri" json:"redirect_uri"`

	// Scope Space-separated list of scopes (e.g., 'openid profile email')
	Scope *string `form:"scope,omitempty" json:"scope,omitempty"`

	// State Opaque value for CSRF protection
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// CodeChallenge PKCE code challenge (base64url-encoded SHA256 hash)
	CodeChallenge string `form:"code_challenge" json:"code_challenge"`

	// CodeChallengeMethod Must be 'S256' for PKCE
	CodeChallengeMethod AuthorizeParamsCodeChallengeMethod `form:"code_challenge_method" json:"code_challenge_method"`

	// Nonce String value for ID token replay protection
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty"`
}

// AuthorizeParamsResponseType defines parameters for Authorize.
type AuthorizeParamsResponseType string

// AuthorizeParamsCodeChallengeMethod defines parameters for Authorize.
type AuthorizeParamsCodeChallengeMethod string

// AuthorizeConsentFormdataBody defines parameters for AuthorizeConsent.
type AuthorizeConsentFormdataBody struct {
	ClientId            string                                          `form:"client_id" json:"client_id"`
	CodeChallenge       string                                          `form:"code_challenge" json:"code_challenge"`
	CodeChallengeMethod AuthorizeConsentFormdataBodyCodeChallengeMethod `form:"code_challenge_method" json:"code_challenge_method"`
	Nonce               *string                                         `form:"nonce,omitempty" json:"nonce,omitempty"`
	RedirectUri         string                                          `form:"redirect_uri" json:"redirect_uri"`
	ResponseType        AuthorizeConsentFormdataBodyResponseType        `form:"response_type" json:"response_type"`
	Scope               *string                                         `form:"scope,omitempty" json:"scope,omitempty"`
	State               *string                                         `form:"state,omitempty" json:"state,omitempty"`
}

// AuthorizeConsentFormdataBodyCodeChallengeMethod defines parameters for AuthorizeConsent.
type AuthorizeConsentFormdataBodyCodeChallengeMethod string

// AuthorizeConsentFormdataBodyResponseType defines parameters for AuthorizeConsent.
type AuthorizeConsentFormdataBodyResponseType string

// ListDevicesParams defines parameters for ListDevices.
type ListDevicesParams struct {
	// XDeviceID Device identifier for device-bound operations
	XDeviceID *openapi_types.UUID `json:"X-Device-ID,omitempty"`
}

// LogoutAllOthersParams defines parameters for LogoutAllOthers.
type LogoutAllOthersParams struct {
	// XDeviceID Device identifier for device-bound operations
	XDeviceID *openapi_types.UUID `json:"X-Device-ID,omitempty"`
}

// CreateClientJSONBody defines parameters for CreateClient.
type CreateClientJSONBody struct {
	// GrantTypes Allowed grant types
	GrantTypes []CreateClientJSONBodyGrantTypes `json:"grant_types"`

	// IsConfidential Whether client can keep secrets confidential
	IsConfidential *bool `json:"is_confidential,omitempty"`

	// Name Human-readable client name
	Name string `json:"name"`

	// RedirectUris Allowed redirect URIs
	RedirectUris []string `json:"redirect_uris"`

	// Scopes Allowed scopes
	Scopes *[]string `json:"scopes,omitempty"`
}

// CreateClientJSONBodyGrantTypes defines parameters for CreateClient.
type CreateClientJSONBodyGrantTypes string

// TokenFormdataBody defines parameters for Token.
type TokenFormdataBody struct {
	ClientId *string `form:"client_id,omitempty" json:"client_id,omitempty"`

	// ClientSecret Client secret (for confidential clients)
	ClientSecret *string `form:"client_secret,omitempty" json:"client_secret,omitempty"`

	// Code Authorization code (for authorization_code grant)
	Code *string `form:"code,omitempty" json:"code,omitempty"`

	// CodeVerifier PKCE code verifier (for authorization_code grant)
	CodeVerifier *string `form:"code_verifier,omitempty" json:"code_verifier,omitempty"`

	// DeviceId Device ID (for refresh_token grant)
	DeviceId  *string                    `form:"device_id,omitempty" json:"device_id,omitempty"`
	GrantType TokenFormdataBodyGrantType `form:"grant_type" json:"grant_type"`

	// RedirectUri Must match original redirect_uri (for authorization_code grant)
	RedirectUri *string `form:"redirect_uri,omitempty" json:"redirect_uri,omitempty"`

	// RefreshToken Refresh token (for refresh_token grant)
	RefreshToken *string `form:"refresh_token,omitempty" json:"refresh_token,omitempty"`
	Scope        *string `form:"scope,omitempty" json:"scope,omitempty"`
}

// TokenFormdataBodyGrantType defines parameters for Token.
type TokenFormdataBodyGrantType string

// RefreshTokenJSONBody defines parameters for RefreshToken.
type RefreshTokenJSONBody struct {
	ClientId     string `json:"client_id"`
	DeviceId     string `json:"device_id"`
	RefreshToken string `json:"refresh_token"`
}

// RevokeTokenJSONBody defines parameters for RevokeToken.
type RevokeTokenJSONBody struct {
	// Token The token to revoke (access or refresh token)
	Token string `json:"token"`

	// TokenTypeHint Hint about the token type
	TokenTypeHint *RevokeTokenJSONBodyTokenTypeHint `json:"token_type_hint,omitempty"`
}

// RevokeTokenJSONBodyTokenTypeHint defines parameters for RevokeToken.
type RevokeTokenJSONBodyTokenTypeHint string

// LoginJSONRequestBody defines body for Login for application/json ContentType.
type LoginJSONRequestBody LoginJSONBody

// RegisterJSONRequestBody defines body for Register for application/json ContentType.
type RegisterJSONRequestBody RegisterJSONBody

// AuthorizeConsentFormdataRequestBody defines body for AuthorizeConsent for application/x-www-form-urlencoded ContentType.
type AuthorizeConsentFormdataRequestBody AuthorizeConsentFormdataBody

// CreateClientJSONRequestBody defines body for CreateClient for application/json ContentType.
type CreateClientJSONRequestBody CreateClientJSONBody

// TokenFormdataRequestBody defines body for Token for application/x-www-form-urlencoded ContentType.
type TokenFormdataRequestBody TokenFormdataBody

// RefreshTokenJSONRequestBody defines body for RefreshToken for application/json ContentType.
type RefreshTokenJSONRequestBody RefreshTokenJSONBody

// RevokeTokenJSONRequestBody defines body for RevokeToken for application/json ContentType.
type RevokeTokenJSONRequestBody RevokeTokenJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetOpenIDConfiguration request
	GetOpenIDConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoginWithBody request with any body
	LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Logout request
	Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterWithBody request with any body
	RegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Register(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Authorize request
	Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthorizeConsentWithBody request with any body
	AuthorizeConsentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthorizeConsentWithFormdataBody(ctx context.Context, body AuthorizeConsentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDevices request
	ListDevices(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealth request
	GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJWKS request
	GetJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLive request
	GetLive(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogoutAll request
	LogoutAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogoutDevice request
	LogoutDevice(ctx context.Context, deviceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LogoutAllOthers request
	LogoutAllOthers(ctx context.Context, params *LogoutAllOthersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClientWithBody request with any body
	CreateClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateClient(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReady request
	GetReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TokenWithBody request with any body
	TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TokenWithFormdataBody(ctx context.Context, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RefreshTokenWithBody request with any body
	RefreshTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RefreshToken(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RevokeTokenWithBody request with any body
	RevokeTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RevokeToken(ctx context.Context, body RevokeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetOpenIDConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenIDConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoginWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Login(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoginRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Logout(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Register(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Authorize(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthorizeConsentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeConsentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthorizeConsentWithFormdataBody(ctx context.Context, body AuthorizeConsentFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthorizeConsentRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDevices(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDevicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJWKS(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJWKSRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLive(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLiveRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogoutAll(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutAllRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogoutDevice(ctx context.Context, deviceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutDeviceRequest(c.Server, deviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LogoutAllOthers(ctx context.Context, params *LogoutAllOthersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLogoutAllOthersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClientWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClient(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClientRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReadyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TokenWithFormdataBody(ctx context.Context, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RefreshToken(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRefreshTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RevokeToken(ctx context.Context, body RevokeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRevokeTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetOpenIDConfigurationRequest generates requests for GetOpenIDConfiguration
func NewGetOpenIDConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/.well-known/openid-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLoginRequest calls the generic Login builder with application/json body
func NewLoginRequest(server string, body LoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoginRequestWithBody(server, "application/json", bodyReader)
}

// NewLoginRequestWithBody generates requests for Login with any type of body
func NewLoginRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLogoutRequest generates requests for Logout
func NewLogoutRequest(server string, params *LogoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XDeviceID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Device-ID", headerParam0)
		}

	}

	return req, nil
}

// NewRegisterRequest calls the generic Register builder with application/json body
func NewRegisterRequest(server string, body RegisterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterRequestWithBody generates requests for Register with any type of body
func NewRegisterRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/register")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthorizeRequest generates requests for Authorize
func NewAuthorizeRequest(server string, params *AuthorizeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Scope != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scope", runtime.ParamLocationQuery, *params.Scope); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge", runtime.ParamLocationQuery, params.CodeChallenge); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code_challenge_method", runtime.ParamLocationQuery, params.CodeChallengeMethod); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Nonce != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nonce", runtime.ParamLocationQuery, *params.Nonce); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthorizeConsentRequestWithFormdataBody calls the generic AuthorizeConsent builder with application/x-www-form-urlencoded body
func NewAuthorizeConsentRequestWithFormdataBody(server string, body AuthorizeConsentFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewAuthorizeConsentRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewAuthorizeConsentRequestWithBody generates requests for AuthorizeConsent with any type of body
func NewAuthorizeConsentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorize")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDevicesRequest generates requests for ListDevices
func NewListDevicesRequest(server string, params *ListDevicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/devices")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XDeviceID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Device-ID", headerParam0)
		}

	}

	return req, nil
}

// NewGetHealthRequest generates requests for GetHealth
func NewGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJWKSRequest generates requests for GetJWKS
func NewGetJWKSRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jwks.json")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLiveRequest generates requests for GetLive
func NewGetLiveRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/live")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogoutAllRequest generates requests for LogoutAll
func NewLogoutAllRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogoutDeviceRequest generates requests for LogoutDevice
func NewLogoutDeviceRequest(server string, deviceId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "device_id", runtime.ParamLocationPath, deviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout/device/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLogoutAllOthersRequest generates requests for LogoutAllOthers
func NewLogoutAllOthersRequest(server string, params *LogoutAllOthersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logout/others")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XDeviceID != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Device-ID", runtime.ParamLocationHeader, *params.XDeviceID)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Device-ID", headerParam0)
		}

	}

	return req, nil
}

// NewCreateClientRequest calls the generic CreateClient builder with application/json body
func NewCreateClientRequest(server string, body CreateClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClientRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateClientRequestWithBody generates requests for CreateClient with any type of body
func NewCreateClientRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth/client")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReadyRequest generates requests for GetReady
func NewGetReadyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTokenRequestWithFormdataBody calls the generic Token builder with application/x-www-form-urlencoded body
func NewTokenRequestWithFormdataBody(server string, body TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewTokenRequestWithBody generates requests for Token with any type of body
func NewTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRefreshTokenRequest calls the generic RefreshToken builder with application/json body
func NewRefreshTokenRequest(server string, body RefreshTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRefreshTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewRefreshTokenRequestWithBody generates requests for RefreshToken with any type of body
func NewRefreshTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRevokeTokenRequest calls the generic RevokeToken builder with application/json body
func NewRevokeTokenRequest(server string, body RevokeTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRevokeTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewRevokeTokenRequestWithBody generates requests for RevokeToken with any type of body
func NewRevokeTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token/revoke")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetOpenIDConfigurationWithResponse request
	GetOpenIDConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenIDConfigurationResponse, error)

	// LoginWithBodyWithResponse request with any body
	LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error)

	// LogoutWithResponse request
	LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error)

	// RegisterWithBodyWithResponse request with any body
	RegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterResponse, error)

	RegisterWithResponse(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterResponse, error)

	// AuthorizeWithResponse request
	AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error)

	// AuthorizeConsentWithBodyWithResponse request with any body
	AuthorizeConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthorizeConsentResponse, error)

	AuthorizeConsentWithFormdataBodyWithResponse(ctx context.Context, body AuthorizeConsentFormdataRequestBody, reqEditors ...RequestEditorFn) (*AuthorizeConsentResponse, error)

	// ListDevicesWithResponse request
	ListDevicesWithResponse(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*ListDevicesResponse, error)

	// GetHealthWithResponse request
	GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error)

	// GetJWKSWithResponse request
	GetJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJWKSResponse, error)

	// GetLiveWithResponse request
	GetLiveWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLiveResponse, error)

	// LogoutAllWithResponse request
	LogoutAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutAllResponse, error)

	// LogoutDeviceWithResponse request
	LogoutDeviceWithResponse(ctx context.Context, deviceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*LogoutDeviceResponse, error)

	// LogoutAllOthersWithResponse request
	LogoutAllOthersWithResponse(ctx context.Context, params *LogoutAllOthersParams, reqEditors ...RequestEditorFn) (*LogoutAllOthersResponse, error)

	// CreateClientWithBodyWithResponse request with any body
	CreateClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	CreateClientWithResponse(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error)

	// GetReadyWithResponse request
	GetReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadyResponse, error)

	// TokenWithBodyWithResponse request with any body
	TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	TokenWithFormdataBodyWithResponse(ctx context.Context, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error)

	// RefreshTokenWithBodyWithResponse request with any body
	RefreshTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error)

	RefreshTokenWithResponse(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error)

	// RevokeTokenWithBodyWithResponse request with any body
	RevokeTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error)

	RevokeTokenWithResponse(ctx context.Context, body RevokeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error)
}

type GetOpenIDConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AuthorizationEndpoint             *string   `json:"authorization_endpoint,omitempty"`
		ClaimsSupported                   *[]string `json:"claims_supported,omitempty"`
		CodeChallengeMethodsSupported     *[]string `json:"code_challenge_methods_supported,omitempty"`
		EndSessionEndpoint                *string   `json:"end_session_endpoint,omitempty"`
		GrantTypesSupported               *[]string `json:"grant_types_supported,omitempty"`
		IdTokenSigningAlgValuesSupported  *[]string `json:"id_token_signing_alg_values_supported,omitempty"`
		IntrospectionEndpoint             *string   `json:"introspection_endpoint,omitempty"`
		Issuer                            *string   `json:"issuer,omitempty"`
		JwksUri                           *string   `json:"jwks_uri,omitempty"`
		RegistrationEndpoint              *string   `json:"registration_endpoint,omitempty"`
		ResponseModesSupported            *[]string `json:"response_modes_supported,omitempty"`
		ResponseTypesSupported            *[]string `json:"response_types_supported,omitempty"`
		RevocationEndpoint                *string   `json:"revocation_endpoint,omitempty"`
		ScopesSupported                   *[]string `json:"scopes_supported,omitempty"`
		SubjectTypesSupported             *[]string `json:"subject_types_supported,omitempty"`
		TokenEndpoint                     *string   `json:"token_endpoint,omitempty"`
		TokenEndpointAuthMethodsSupported *[]string `json:"token_endpoint_auth_methods_supported,omitempty"`
		UserinfoEndpoint                  *string   `json:"userinfo_endpoint,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOpenIDConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenIDConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AccessToken JWT access token
		AccessToken *string `json:"access_token,omitempty"`

		// DeviceId Server-assigned device identifier
		DeviceId *openapi_types.UUID `json:"device_id,omitempty"`

		// ExpiresIn Token lifetime in seconds
		ExpiresIn *int `json:"expires_in,omitempty"`

		// IdToken OpenID Connect ID token (when openid scope requested)
		IdToken *string `json:"id_token,omitempty"`

		// RefreshToken Refresh token for obtaining new access tokens
		RefreshToken *string `json:"refresh_token,omitempty"`

		// Scope Granted scopes
		Scope     *string `json:"scope,omitempty"`
		TokenType *string `json:"token_type,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r LoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r LogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		CreatedAt     *time.Time           `json:"created_at,omitempty"`
		Email         *openapi_types.Email `json:"email,omitempty"`
		EmailVerified *bool                `json:"email_verified,omitempty"`
		UserId        *openapi_types.UUID  `json:"user_id,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON409 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r RegisterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ClientId    *string `json:"client_id,omitempty"`
		ClientName  *string `json:"client_name,omitempty"`
		Message     *string `json:"message,omitempty"`
		RedirectUri *string `json:"redirect_uri,omitempty"`
		Scope       *string `json:"scope,omitempty"`
		State       *string `json:"state,omitempty"`
	}
	JSON400 *struct {
		// Error OAuth error code
		Error Authorize400Error `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription *string `json:"error_description,omitempty"`
	}
}
type Authorize400Error string

// Status returns HTTPResponse.Status
func (r AuthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthorizeConsentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		// Error OAuth error code
		Error AuthorizeConsent400Error `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription *string `json:"error_description,omitempty"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}
type AuthorizeConsent400Error string

// Status returns HTTPResponse.Status
func (r AuthorizeConsentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthorizeConsentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Devices *[]struct {
			CreatedAt  *time.Time          `json:"created_at,omitempty"`
			DeviceId   *openapi_types.UUID `json:"device_id,omitempty"`
			DeviceName *string             `json:"device_name,omitempty"`
			IpAddress  *string             `json:"ip_address,omitempty"`

			// IsCurrent Whether this is the current device making the request
			IsCurrent  *bool      `json:"is_current,omitempty"`
			LastUsedAt *time.Time `json:"last_used_at,omitempty"`
			UserAgent  *string    `json:"user_agent,omitempty"`
		} `json:"devices,omitempty"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Checks struct {
			Database *GetHealth200ChecksDatabase `json:"database,omitempty"`
			Redis    *GetHealth200ChecksRedis    `json:"redis,omitempty"`
		} `json:"checks"`
		Status GetHealth200Status `json:"status"`
	}
	JSON503 *struct {
		Checks struct {
			Database *GetHealth503ChecksDatabase `json:"database,omitempty"`
			Redis    *GetHealth503ChecksRedis    `json:"redis,omitempty"`
		} `json:"checks"`
		Status GetHealth503Status `json:"status"`
	}
}
type GetHealth200ChecksDatabase string
type GetHealth200ChecksRedis string
type GetHealth200Status string
type GetHealth503ChecksDatabase string
type GetHealth503ChecksRedis string
type GetHealth503Status string

// Status returns HTTPResponse.Status
func (r GetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJWKSResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Keys *[]struct {
			Alg *string `json:"alg,omitempty"`

			// E RSA exponent (base64url encoded)
			E *string `json:"e,omitempty"`

			// Kid Key ID
			Kid *string `json:"kid,omitempty"`
			Kty *string `json:"kty,omitempty"`

			// N RSA modulus (base64url encoded)
			N   *string `json:"n,omitempty"`
			Use *string `json:"use,omitempty"`
		} `json:"keys,omitempty"`
	}
	JSON500 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJWKSResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJWKSResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Alive *bool `json:"alive,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutAllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r LogoutAllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutAllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON404 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r LogoutDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LogoutAllOthersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON401 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r LogoutAllOthersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LogoutAllOthersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// ClientId OAuth client ID
		ClientId *string `json:"client_id,omitempty"`

		// ClientSecret Client secret (only returned on creation)
		ClientSecret *string             `json:"client_secret,omitempty"`
		CreatedAt    *time.Time          `json:"created_at,omitempty"`
		GrantTypes   *[]string           `json:"grant_types,omitempty"`
		Id           *openapi_types.UUID `json:"id,omitempty"`
		Name         *string             `json:"name,omitempty"`
		RedirectUris *[]string           `json:"redirect_uris,omitempty"`
		Scopes       *[]string           `json:"scopes,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
	JSON500 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateClientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ready *bool `json:"ready,omitempty"`
	}
	JSON503 *struct {
		Ready *bool `json:"ready,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccessToken  *string `json:"access_token,omitempty"`
		DeviceId     *string `json:"device_id,omitempty"`
		ExpiresIn    *int    `json:"expires_in,omitempty"`
		IdToken      *string `json:"id_token,omitempty"`
		RefreshToken *string `json:"refresh_token,omitempty"`
		Scope        *string `json:"scope,omitempty"`
		TokenType    *string `json:"token_type,omitempty"`
	}
	JSON400 *struct {
		// Error OAuth error code
		Error Token400Error `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription *string `json:"error_description,omitempty"`
	}
	JSON401 *struct {
		// Error OAuth error code
		Error Token401Error `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription *string `json:"error_description,omitempty"`
	}
}
type Token400Error string
type Token401Error string

// Status returns HTTPResponse.Status
func (r TokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RefreshTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AccessToken  *string `json:"access_token,omitempty"`
		DeviceId     *string `json:"device_id,omitempty"`
		ExpiresIn    *int    `json:"expires_in,omitempty"`
		IdToken      *string `json:"id_token,omitempty"`
		RefreshToken *string `json:"refresh_token,omitempty"`
		Scope        *string `json:"scope,omitempty"`
		TokenType    *string `json:"token_type,omitempty"`
	}
	JSON400 *struct {
		// Error OAuth error code
		Error RefreshToken400Error `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription *string `json:"error_description,omitempty"`
	}
}
type RefreshToken400Error string

// Status returns HTTPResponse.Status
func (r RefreshTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RefreshTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RevokeTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Revoked *bool `json:"revoked,omitempty"`
	}
	JSON400 *struct {
		// Error Error code
		Error string `json:"error"`

		// ErrorDescription Human-readable error description
		ErrorDescription string `json:"error_description"`
	}
}

// Status returns HTTPResponse.Status
func (r RevokeTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RevokeTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetOpenIDConfigurationWithResponse request returning *GetOpenIDConfigurationResponse
func (c *ClientWithResponses) GetOpenIDConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenIDConfigurationResponse, error) {
	rsp, err := c.GetOpenIDConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenIDConfigurationResponse(rsp)
}

// LoginWithBodyWithResponse request with arbitrary body returning *LoginResponse
func (c *ClientWithResponses) LoginWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.LoginWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

func (c *ClientWithResponses) LoginWithResponse(ctx context.Context, body LoginJSONRequestBody, reqEditors ...RequestEditorFn) (*LoginResponse, error) {
	rsp, err := c.Login(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoginResponse(rsp)
}

// LogoutWithResponse request returning *LogoutResponse
func (c *ClientWithResponses) LogoutWithResponse(ctx context.Context, params *LogoutParams, reqEditors ...RequestEditorFn) (*LogoutResponse, error) {
	rsp, err := c.Logout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutResponse(rsp)
}

// RegisterWithBodyWithResponse request with arbitrary body returning *RegisterResponse
func (c *ClientWithResponses) RegisterWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterResponse, error) {
	rsp, err := c.RegisterWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterResponse(rsp)
}

func (c *ClientWithResponses) RegisterWithResponse(ctx context.Context, body RegisterJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterResponse, error) {
	rsp, err := c.Register(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterResponse(rsp)
}

// AuthorizeWithResponse request returning *AuthorizeResponse
func (c *ClientWithResponses) AuthorizeWithResponse(ctx context.Context, params *AuthorizeParams, reqEditors ...RequestEditorFn) (*AuthorizeResponse, error) {
	rsp, err := c.Authorize(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeResponse(rsp)
}

// AuthorizeConsentWithBodyWithResponse request with arbitrary body returning *AuthorizeConsentResponse
func (c *ClientWithResponses) AuthorizeConsentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthorizeConsentResponse, error) {
	rsp, err := c.AuthorizeConsentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeConsentResponse(rsp)
}

func (c *ClientWithResponses) AuthorizeConsentWithFormdataBodyWithResponse(ctx context.Context, body AuthorizeConsentFormdataRequestBody, reqEditors ...RequestEditorFn) (*AuthorizeConsentResponse, error) {
	rsp, err := c.AuthorizeConsentWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthorizeConsentResponse(rsp)
}

// ListDevicesWithResponse request returning *ListDevicesResponse
func (c *ClientWithResponses) ListDevicesWithResponse(ctx context.Context, params *ListDevicesParams, reqEditors ...RequestEditorFn) (*ListDevicesResponse, error) {
	rsp, err := c.ListDevices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDevicesResponse(rsp)
}

// GetHealthWithResponse request returning *GetHealthResponse
func (c *ClientWithResponses) GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error) {
	rsp, err := c.GetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthResponse(rsp)
}

// GetJWKSWithResponse request returning *GetJWKSResponse
func (c *ClientWithResponses) GetJWKSWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetJWKSResponse, error) {
	rsp, err := c.GetJWKS(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJWKSResponse(rsp)
}

// GetLiveWithResponse request returning *GetLiveResponse
func (c *ClientWithResponses) GetLiveWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLiveResponse, error) {
	rsp, err := c.GetLive(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLiveResponse(rsp)
}

// LogoutAllWithResponse request returning *LogoutAllResponse
func (c *ClientWithResponses) LogoutAllWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LogoutAllResponse, error) {
	rsp, err := c.LogoutAll(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutAllResponse(rsp)
}

// LogoutDeviceWithResponse request returning *LogoutDeviceResponse
func (c *ClientWithResponses) LogoutDeviceWithResponse(ctx context.Context, deviceId openapi_types.UUID, reqEditors ...RequestEditorFn) (*LogoutDeviceResponse, error) {
	rsp, err := c.LogoutDevice(ctx, deviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutDeviceResponse(rsp)
}

// LogoutAllOthersWithResponse request returning *LogoutAllOthersResponse
func (c *ClientWithResponses) LogoutAllOthersWithResponse(ctx context.Context, params *LogoutAllOthersParams, reqEditors ...RequestEditorFn) (*LogoutAllOthersResponse, error) {
	rsp, err := c.LogoutAllOthers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLogoutAllOthersResponse(rsp)
}

// CreateClientWithBodyWithResponse request with arbitrary body returning *CreateClientResponse
func (c *ClientWithResponses) CreateClientWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClientWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

func (c *ClientWithResponses) CreateClientWithResponse(ctx context.Context, body CreateClientJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClientResponse, error) {
	rsp, err := c.CreateClient(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClientResponse(rsp)
}

// GetReadyWithResponse request returning *GetReadyResponse
func (c *ClientWithResponses) GetReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadyResponse, error) {
	rsp, err := c.GetReady(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReadyResponse(rsp)
}

// TokenWithBodyWithResponse request with arbitrary body returning *TokenResponse
func (c *ClientWithResponses) TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.TokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

func (c *ClientWithResponses) TokenWithFormdataBodyWithResponse(ctx context.Context, body TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*TokenResponse, error) {
	rsp, err := c.TokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTokenResponse(rsp)
}

// RefreshTokenWithBodyWithResponse request with arbitrary body returning *RefreshTokenResponse
func (c *ClientWithResponses) RefreshTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error) {
	rsp, err := c.RefreshTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenResponse(rsp)
}

func (c *ClientWithResponses) RefreshTokenWithResponse(ctx context.Context, body RefreshTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RefreshTokenResponse, error) {
	rsp, err := c.RefreshToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRefreshTokenResponse(rsp)
}

// RevokeTokenWithBodyWithResponse request with arbitrary body returning *RevokeTokenResponse
func (c *ClientWithResponses) RevokeTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error) {
	rsp, err := c.RevokeTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeTokenResponse(rsp)
}

func (c *ClientWithResponses) RevokeTokenWithResponse(ctx context.Context, body RevokeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*RevokeTokenResponse, error) {
	rsp, err := c.RevokeToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRevokeTokenResponse(rsp)
}

// ParseGetOpenIDConfigurationResponse parses an HTTP response from a GetOpenIDConfigurationWithResponse call
func ParseGetOpenIDConfigurationResponse(rsp *http.Response) (*GetOpenIDConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenIDConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AuthorizationEndpoint             *string   `json:"authorization_endpoint,omitempty"`
			ClaimsSupported                   *[]string `json:"claims_supported,omitempty"`
			CodeChallengeMethodsSupported     *[]string `json:"code_challenge_methods_supported,omitempty"`
			EndSessionEndpoint                *string   `json:"end_session_endpoint,omitempty"`
			GrantTypesSupported               *[]string `json:"grant_types_supported,omitempty"`
			IdTokenSigningAlgValuesSupported  *[]string `json:"id_token_signing_alg_values_supported,omitempty"`
			IntrospectionEndpoint             *string   `json:"introspection_endpoint,omitempty"`
			Issuer                            *string   `json:"issuer,omitempty"`
			JwksUri                           *string   `json:"jwks_uri,omitempty"`
			RegistrationEndpoint              *string   `json:"registration_endpoint,omitempty"`
			ResponseModesSupported            *[]string `json:"response_modes_supported,omitempty"`
			ResponseTypesSupported            *[]string `json:"response_types_supported,omitempty"`
			RevocationEndpoint                *string   `json:"revocation_endpoint,omitempty"`
			ScopesSupported                   *[]string `json:"scopes_supported,omitempty"`
			SubjectTypesSupported             *[]string `json:"subject_types_supported,omitempty"`
			TokenEndpoint                     *string   `json:"token_endpoint,omitempty"`
			TokenEndpointAuthMethodsSupported *[]string `json:"token_endpoint_auth_methods_supported,omitempty"`
			UserinfoEndpoint                  *string   `json:"userinfo_endpoint,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLoginResponse parses an HTTP response from a LoginWithResponse call
func ParseLoginResponse(rsp *http.Response) (*LoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AccessToken JWT access token
			AccessToken *string `json:"access_token,omitempty"`

			// DeviceId Server-assigned device identifier
			DeviceId *openapi_types.UUID `json:"device_id,omitempty"`

			// ExpiresIn Token lifetime in seconds
			ExpiresIn *int `json:"expires_in,omitempty"`

			// IdToken OpenID Connect ID token (when openid scope requested)
			IdToken *string `json:"id_token,omitempty"`

			// RefreshToken Refresh token for obtaining new access tokens
			RefreshToken *string `json:"refresh_token,omitempty"`

			// Scope Granted scopes
			Scope     *string `json:"scope,omitempty"`
			TokenType *string `json:"token_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLogoutResponse parses an HTTP response from a LogoutWithResponse call
func ParseLogoutResponse(rsp *http.Response) (*LogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRegisterResponse parses an HTTP response from a RegisterWithResponse call
func ParseRegisterResponse(rsp *http.Response) (*RegisterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			CreatedAt     *time.Time           `json:"created_at,omitempty"`
			Email         *openapi_types.Email `json:"email,omitempty"`
			EmailVerified *bool                `json:"email_verified,omitempty"`
			UserId        *openapi_types.UUID  `json:"user_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseAuthorizeResponse parses an HTTP response from a AuthorizeWithResponse call
func ParseAuthorizeResponse(rsp *http.Response) (*AuthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ClientId    *string `json:"client_id,omitempty"`
			ClientName  *string `json:"client_name,omitempty"`
			Message     *string `json:"message,omitempty"`
			RedirectUri *string `json:"redirect_uri,omitempty"`
			Scope       *string `json:"scope,omitempty"`
			State       *string `json:"state,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error OAuth error code
			Error Authorize400Error `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription *string `json:"error_description,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAuthorizeConsentResponse parses an HTTP response from a AuthorizeConsentWithResponse call
func ParseAuthorizeConsentResponse(rsp *http.Response) (*AuthorizeConsentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthorizeConsentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error OAuth error code
			Error AuthorizeConsent400Error `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription *string `json:"error_description,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListDevicesResponse parses an HTTP response from a ListDevicesWithResponse call
func ParseListDevicesResponse(rsp *http.Response) (*ListDevicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Devices *[]struct {
				CreatedAt  *time.Time          `json:"created_at,omitempty"`
				DeviceId   *openapi_types.UUID `json:"device_id,omitempty"`
				DeviceName *string             `json:"device_name,omitempty"`
				IpAddress  *string             `json:"ip_address,omitempty"`

				// IsCurrent Whether this is the current device making the request
				IsCurrent  *bool      `json:"is_current,omitempty"`
				LastUsedAt *time.Time `json:"last_used_at,omitempty"`
				UserAgent  *string    `json:"user_agent,omitempty"`
			} `json:"devices,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetHealthResponse parses an HTTP response from a GetHealthWithResponse call
func ParseGetHealthResponse(rsp *http.Response) (*GetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Checks struct {
				Database *GetHealth200ChecksDatabase `json:"database,omitempty"`
				Redis    *GetHealth200ChecksRedis    `json:"redis,omitempty"`
			} `json:"checks"`
			Status GetHealth200Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Checks struct {
				Database *GetHealth503ChecksDatabase `json:"database,omitempty"`
				Redis    *GetHealth503ChecksRedis    `json:"redis,omitempty"`
			} `json:"checks"`
			Status GetHealth503Status `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseGetJWKSResponse parses an HTTP response from a GetJWKSWithResponse call
func ParseGetJWKSResponse(rsp *http.Response) (*GetJWKSResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJWKSResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Keys *[]struct {
				Alg *string `json:"alg,omitempty"`

				// E RSA exponent (base64url encoded)
				E *string `json:"e,omitempty"`

				// Kid Key ID
				Kid *string `json:"kid,omitempty"`
				Kty *string `json:"kty,omitempty"`

				// N RSA modulus (base64url encoded)
				N   *string `json:"n,omitempty"`
				Use *string `json:"use,omitempty"`
			} `json:"keys,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetLiveResponse parses an HTTP response from a GetLiveWithResponse call
func ParseGetLiveResponse(rsp *http.Response) (*GetLiveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Alive *bool `json:"alive,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLogoutAllResponse parses an HTTP response from a LogoutAllWithResponse call
func ParseLogoutAllResponse(rsp *http.Response) (*LogoutAllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutAllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLogoutDeviceResponse parses an HTTP response from a LogoutDeviceWithResponse call
func ParseLogoutDeviceResponse(rsp *http.Response) (*LogoutDeviceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseLogoutAllOthersResponse parses an HTTP response from a LogoutAllOthersWithResponse call
func ParseLogoutAllOthersResponse(rsp *http.Response) (*LogoutAllOthersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LogoutAllOthersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateClientResponse parses an HTTP response from a CreateClientWithResponse call
func ParseCreateClientResponse(rsp *http.Response) (*CreateClientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// ClientId OAuth client ID
			ClientId *string `json:"client_id,omitempty"`

			// ClientSecret Client secret (only returned on creation)
			ClientSecret *string             `json:"client_secret,omitempty"`
			CreatedAt    *time.Time          `json:"created_at,omitempty"`
			GrantTypes   *[]string           `json:"grant_types,omitempty"`
			Id           *openapi_types.UUID `json:"id,omitempty"`
			Name         *string             `json:"name,omitempty"`
			RedirectUris *[]string           `json:"redirect_uris,omitempty"`
			Scopes       *[]string           `json:"scopes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetReadyResponse parses an HTTP response from a GetReadyWithResponse call
func ParseGetReadyResponse(rsp *http.Response) (*GetReadyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ready *bool `json:"ready,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Ready *bool `json:"ready,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTokenResponse parses an HTTP response from a TokenWithResponse call
func ParseTokenResponse(rsp *http.Response) (*TokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccessToken  *string `json:"access_token,omitempty"`
			DeviceId     *string `json:"device_id,omitempty"`
			ExpiresIn    *int    `json:"expires_in,omitempty"`
			IdToken      *string `json:"id_token,omitempty"`
			RefreshToken *string `json:"refresh_token,omitempty"`
			Scope        *string `json:"scope,omitempty"`
			TokenType    *string `json:"token_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error OAuth error code
			Error Token400Error `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription *string `json:"error_description,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			// Error OAuth error code
			Error Token401Error `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription *string `json:"error_description,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseRefreshTokenResponse parses an HTTP response from a RefreshTokenWithResponse call
func ParseRefreshTokenResponse(rsp *http.Response) (*RefreshTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RefreshTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AccessToken  *string `json:"access_token,omitempty"`
			DeviceId     *string `json:"device_id,omitempty"`
			ExpiresIn    *int    `json:"expires_in,omitempty"`
			IdToken      *string `json:"id_token,omitempty"`
			RefreshToken *string `json:"refresh_token,omitempty"`
			Scope        *string `json:"scope,omitempty"`
			TokenType    *string `json:"token_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error OAuth error code
			Error RefreshToken400Error `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription *string `json:"error_description,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRevokeTokenResponse parses an HTTP response from a RevokeTokenWithResponse call
func ParseRevokeTokenResponse(rsp *http.Response) (*RevokeTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RevokeTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Revoked *bool `json:"revoked,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Error Error code
			Error string `json:"error"`

			// ErrorDescription Human-readable error description
			ErrorDescription string `json:"error_description"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// OpenID Connect discovery document
	// (GET /.well-known/openid-configuration)
	GetOpenIDConfiguration(c *gin.Context)
	// User login
	// (POST /auth/login)
	Login(c *gin.Context)
	// Logout current device
	// (POST /auth/logout)
	Logout(c *gin.Context, params LogoutParams)
	// Register a new user
	// (POST /auth/register)
	Register(c *gin.Context)
	// Authorization endpoint
	// (GET /authorize)
	Authorize(c *gin.Context, params AuthorizeParams)
	// Authorization consent
	// (POST /authorize)
	AuthorizeConsent(c *gin.Context)
	// List user devices
	// (GET /devices)
	ListDevices(c *gin.Context, params ListDevicesParams)
	// Service health status
	// (GET /health)
	GetHealth(c *gin.Context)
	// JSON Web Key Set
	// (GET /jwks.json)
	GetJWKS(c *gin.Context)
	// Service liveness
	// (GET /live)
	GetLive(c *gin.Context)
	// Logout all devices
	// (POST /logout/all)
	LogoutAll(c *gin.Context)
	// Logout specific device
	// (POST /logout/device/{device_id})
	LogoutDevice(c *gin.Context, deviceId openapi_types.UUID)
	// Logout all other devices
	// (POST /logout/others)
	LogoutAllOthers(c *gin.Context, params LogoutAllOthersParams)
	// Create OAuth client
	// (POST /oauth/client)
	CreateClient(c *gin.Context)
	// Service readiness
	// (GET /ready)
	GetReady(c *gin.Context)
	// Token endpoint
	// (POST /token)
	Token(c *gin.Context)
	// Refresh token
	// (POST /token/refresh)
	RefreshToken(c *gin.Context)
	// Revoke token
	// (POST /token/revoke)
	RevokeToken(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// GetOpenIDConfiguration operation middleware
func (siw *ServerInterfaceWrapper) GetOpenIDConfiguration(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetOpenIDConfiguration(c)
}

// Login operation middleware
func (siw *ServerInterfaceWrapper) Login(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Login(c)
}

// Logout operation middleware
func (siw *ServerInterfaceWrapper) Logout(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params LogoutParams

	headers := c.Request.Header

	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Device-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Device-ID", valueList[0], &XDeviceID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Device-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XDeviceID = &XDeviceID

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Logout(c, params)
}

// Register operation middleware
func (siw *ServerInterfaceWrapper) Register(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Register(c)
}

// Authorize operation middleware
func (siw *ServerInterfaceWrapper) Authorize(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthorizeParams

	// ------------- Required query parameter "response_type" -------------

	if paramValue := c.Query("response_type"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument response_type is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "response_type", c.Request.URL.Query(), &params.ResponseType)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter response_type: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "client_id" -------------

	if paramValue := c.Query("client_id"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument client_id is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "client_id", c.Request.URL.Query(), &params.ClientId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter client_id: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "redirect_uri" -------------

	if paramValue := c.Query("redirect_uri"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument redirect_uri is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "redirect_uri", c.Request.URL.Query(), &params.RedirectUri)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter redirect_uri: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "scope" -------------

	err = runtime.BindQueryParameter("form", true, false, "scope", c.Request.URL.Query(), &params.Scope)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter scope: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", c.Request.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter state: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "code_challenge" -------------

	if paramValue := c.Query("code_challenge"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument code_challenge is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "code_challenge", c.Request.URL.Query(), &params.CodeChallenge)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter code_challenge: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "code_challenge_method" -------------

	if paramValue := c.Query("code_challenge_method"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument code_challenge_method is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "code_challenge_method", c.Request.URL.Query(), &params.CodeChallengeMethod)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter code_challenge_method: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "nonce" -------------

	err = runtime.BindQueryParameter("form", true, false, "nonce", c.Request.URL.Query(), &params.Nonce)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter nonce: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Authorize(c, params)
}

// AuthorizeConsent operation middleware
func (siw *ServerInterfaceWrapper) AuthorizeConsent(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.AuthorizeConsent(c)
}

// ListDevices operation middleware
func (siw *ServerInterfaceWrapper) ListDevices(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDevicesParams

	headers := c.Request.Header

	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Device-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Device-ID", valueList[0], &XDeviceID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Device-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XDeviceID = &XDeviceID

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListDevices(c, params)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// GetJWKS operation middleware
func (siw *ServerInterfaceWrapper) GetJWKS(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetJWKS(c)
}

// GetLive operation middleware
func (siw *ServerInterfaceWrapper) GetLive(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetLive(c)
}

// LogoutAll operation middleware
func (siw *ServerInterfaceWrapper) LogoutAll(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LogoutAll(c)
}

// LogoutDevice operation middleware
func (siw *ServerInterfaceWrapper) LogoutDevice(c *gin.Context) {

	var err error

	// ------------- Path parameter "device_id" -------------
	var deviceId openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "device_id", c.Param("device_id"), &deviceId, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter device_id: %w", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LogoutDevice(c, deviceId)
}

// LogoutAllOthers operation middleware
func (siw *ServerInterfaceWrapper) LogoutAllOthers(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params LogoutAllOthersParams

	headers := c.Request.Header

	// ------------- Optional header parameter "X-Device-ID" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Device-ID")]; found {
		var XDeviceID openapi_types.UUID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Device-ID, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Device-ID", valueList[0], &XDeviceID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Device-ID: %w", err), http.StatusBadRequest)
			return
		}

		params.XDeviceID = &XDeviceID

	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.LogoutAllOthers(c, params)
}

// CreateClient operation middleware
func (siw *ServerInterfaceWrapper) CreateClient(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateClient(c)
}

// GetReady operation middleware
func (siw *ServerInterfaceWrapper) GetReady(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetReady(c)
}

// Token operation middleware
func (siw *ServerInterfaceWrapper) Token(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.Token(c)
}

// RefreshToken operation middleware
func (siw *ServerInterfaceWrapper) RefreshToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RefreshToken(c)
}

// RevokeToken operation middleware
func (siw *ServerInterfaceWrapper) RevokeToken(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RevokeToken(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/.well-known/openid-configuration", wrapper.GetOpenIDConfiguration)
	router.POST(options.BaseURL+"/auth/login", wrapper.Login)
	router.POST(options.BaseURL+"/auth/logout", wrapper.Logout)
	router.POST(options.BaseURL+"/auth/register", wrapper.Register)
	router.GET(options.BaseURL+"/authorize", wrapper.Authorize)
	router.POST(options.BaseURL+"/authorize", wrapper.AuthorizeConsent)
	router.GET(options.BaseURL+"/devices", wrapper.ListDevices)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.GET(options.BaseURL+"/jwks.json", wrapper.GetJWKS)
	router.GET(options.BaseURL+"/live", wrapper.GetLive)
	router.POST(options.BaseURL+"/logout/all", wrapper.LogoutAll)
	router.POST(options.BaseURL+"/logout/device/:device_id", wrapper.LogoutDevice)
	router.POST(options.BaseURL+"/logout/others", wrapper.LogoutAllOthers)
	router.POST(options.BaseURL+"/oauth/client", wrapper.CreateClient)
	router.GET(options.BaseURL+"/ready", wrapper.GetReady)
	router.POST(options.BaseURL+"/token", wrapper.Token)
	router.POST(options.BaseURL+"/token/refresh", wrapper.RefreshToken)
	router.POST(options.BaseURL+"/token/revoke", wrapper.RevokeToken)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"4ebh/wIAAP//zCCt7VxmAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
